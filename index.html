<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„ØµØ¯ÙŠÙ‚ Ø§Ù„Ø°ÙƒÙŠ</title>
    
    <!-- Ù…ÙƒØªØ¨Ø§Øª Three.js Ù„Ù„Ø±Ø³ÙˆÙ…ÙŠØ§Øª Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script> 
    
    <!-- Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø¨ØµØ±ÙŠ (FaceMesh) --><script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.13.0/dist/tf-backend-webgl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633558237/face_mesh.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@0.0.3/dist/face-landmarks-detection.min.js"></script>


    <style>
        body {
            background-color: #0d1117; 
            color: #eceff1; 
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            text-align: right;
            user-select: none; 
            overflow: hidden; 
        }

        /* ---------------- Ø´Ø§Ø´Ø© Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± ---------------- */
        #selection-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            height: 100vh;
            width: 100%;
            z-index: 100;
            position: absolute;
            background-color: #0d1117;
        }
        #selection-screen h1 {
            color: #00ffff;
            font-size: 2.5em;
        }
        .friend-choice {
            display: flex;
            gap: 30px;
            margin-top: 30px;
        }
        .friend-btn {
            padding: 20px 40px;
            font-size: 1.2em;
            border: 2px solid #00ffff;
            background: #161b22;
            color: #00ffff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .friend-btn:hover {
            background: #00ffff;
            color: #0d1117;
            box-shadow: 0 0 20px #00ffff;
        }

        /* ---------------- Ø´Ø§Ø´Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ---------------- */
        #main-app {
            display: none; 
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.1; 
            z-index: -1;
            transform: scaleX(-1); 
        }
        
        #pose-canvas {
            display: none; 
        }

        #hologram-container {
            width: 100%; 
            height: 60%; 
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; 
            z-index: 10;
        }

        #chat-interface {
            width: 100%;
            height: 40%;
            padding: 20px;
            box-sizing: border-box;
            background-color: #161b22;
            border-top: 2px solid #00ffff;
            border-radius: 20px 20px 0 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #response-display {
            height: 60%;
            overflow-y: auto;
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #eceff1;
        }

        #controls-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        #mic-btn {
            width: 80px;
            height: 80px;
            background-color: #00ffff;
            color: #0d1117;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        
        #mic-btn.listening {
            background-color: #ff5722; 
            color: white;
            box-shadow: 0 0 25px #ff5722;
        }

        #status-message {
            text-align: center;
            font-size: 1.1em;
            color: #ffcc00; 
            height: 20px;
        }
    </style>

</head>
<body>
    <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ÙˆÙ„ÙŠØ© --><div id="selection-screen">
        <h1>Ø§Ø®ØªØ± ØµØ¯ÙŠÙ‚Ùƒ Ø§Ù„Ø°ÙƒÙŠ</h1>
        <div class="friend-choice">
            <button id="select-male" class="friend-btn" onclick="selectFriend('male')">Ø¢Ø¯Ù… (ØµØ¯ÙŠÙ‚)</button>
            <button id="select-female" class="friend-btn" onclick="selectFriend('female')">Ø³Ø§Ø±Ø© (ØµØ¯ÙŠÙ‚Ø©)</button>
        </div>
    </div>
    
    <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (Ù…Ø®ÙÙŠØ©) --><div id="main-app">
        <video id="camera-feed" autoplay playsinline></video>
        <canvas id="pose-canvas"></canvas>
        
        <div id="hologram-container">
            <!-- Three.js Canvas --></div>

        <div id="chat-interface">
            <div id="response-display">
                <p>Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ! Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„Ù…Ø§ÙŠÙƒØ±ÙˆÙÙˆÙ† ÙˆØ§Ø¨Ø¯Ø£ Ø§Ù„ØªØ­Ø¯Ø« Ù…Ø¹ÙŠ.</p>
            </div>
            
            <p id="status-message"></p>

            <div id="controls-area">
                <button id="mic-btn">ğŸ™ï¸</button> 
            </div>
        </div>
    </div>


    <script>
        // =======================================================
        // 1. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Gemini API 
        // =======================================================
        const API_KEY = "AIzaSyAUf6b62PXLjajdhOwROgIfI3aqdvAr6AY"; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        let selectedGender = 'male'; 
        let currentSystemPrompt = "";

        const PROMPTS = {
            male: "Act as an intelligent, witty, and supportive male friend. Your name is 'ADAM' (Ø¢Ø¯Ù…). Speak in Arabic. Be encouraging, share interesting ideas, and be curious about the user's day. Be very conversational and use emojis. Do not act as an assistant; act as a friend.",
            female: "Act as an intelligent, empathetic, and friendly female friend. Your name is 'SARA' (Ø³Ø§Ø±Ø©). Speak in Arabic. Be supportive, ask follow-up questions, and be curious about the user's day. Be very conversational and use emojis. Do not act as an assistant; act as a friend."
        };

        // =======================================================
        // 2. Ù…Ù†Ø·Ù‚ Three.js - Ø§Ù„Ø¹Ø±Ø¶ ÙˆØ§Ù„Ø­Ø±ÙƒØ© (Ù†ØµÙ Ø¹Ù„ÙˆÙŠ)
        // =======================================================
        let scene, camera, renderer, avatar, mixer, clock; 
        let currentAction;
        let availableAnimations = {}; 
        let targetRotationY = 0; 
        const TRACKING_SPEED = 0.05; 
        
        // ğŸš¨ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ù†Ù…Ø§Ø°Ø¬ Ø´Ø¨Ù‡ ÙˆØ§Ù‚Ø¹ÙŠØ©
        const MODEL_URLS = {
            male: 'https://threejs.org/examples/models/gltf/Soldier.glb',
            female: 'https://threejs.org/examples/models/gltf/Woman.glb' // Ù†Ù…ÙˆØ°Ø¬ Ø£Ù†Ø«ÙˆÙŠ Ø¨Ø³ÙŠØ·
        };
        
        clock = new THREE.Clock();
        
        let faceMeshModel = null; 
        const videoElement = document.getElementById('camera-feed');
        const poseCanvas = document.getElementById('pose-canvas');


        function initThreeJS() {
            const container = document.getElementById('hologram-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const aspectRatio = containerWidth / containerHeight;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117); 
            
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            // ğŸš¨ Ø¶Ø¨Ø· Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ù„Ù†ØµÙ Ø§Ù„Ø¹Ù„ÙˆÙŠ Ù„Ù„Ù†Ù…Ø§Ø°Ø¬ Ø´Ø¨Ù‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©
            camera.position.set(0, 1.3, 2.5); // Y Ù„Ø±ÙØ¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù‚Ù„ÙŠÙ„Ø§Ù‹ØŒ Z Ù„Ø¥Ø¨Ø¹Ø§Ø¯Ù‡Ø§
            camera.lookAt(0, 1.0, 0); // Ø§Ù„Ù†Ø¸Ø± Ø¥Ù„Ù‰ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ÙˆØ¬Ù‡/Ø§Ù„ØµØ¯Ø±

            renderer = new THREE.WebGLRenderer({ antialias: true }); 
            renderer.setSize(containerWidth, containerHeight);
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.5)); 
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); 
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            const loader = new THREE.GLTFLoader();
            loader.load(MODEL_URLS[selectedGender], function (gltf) {
                avatar = gltf.scene;
                // ğŸš¨ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                avatar.scale.set(1.5, 1.5, 1.5); 
                avatar.position.y = 0; 
                scene.add(avatar);

                mixer = new THREE.AnimationMixer(avatar);
                
                gltf.animations.forEach((clip) => {
                    availableAnimations[clip.name] = mixer.clipAction(clip);
                });
                
                // ğŸš¨ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬
                availableAnimations['listening'] = availableAnimations['Idle'] || availableAnimations[gltf.animations[0]?.name]; 
                availableAnimations['talking'] = availableAnimations['Walk'] || availableAnimations[gltf.animations[0]?.name];     
                availableAnimations['thinking'] = availableAnimations['Run'] || availableAnimations[gltf.animations[0]?.name];     
                availableAnimations['happy'] = availableAnimations['Jump'] || availableAnimations['Walk'] || availableAnimations[gltf.animations[0]?.name]; 

                // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ Ø­Ø±ÙƒØ©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø§Ù„Ø£ÙˆÙ„Ù‰
                if (!availableAnimations['listening']) {
                     console.warn("No 'Idle' animation found. Using first available animation for 'listening'.");
                     availableAnimations['listening'] = mixer.clipAction(gltf.animations[0]);
                }
                if (!availableAnimations['talking']) {
                     console.warn("No 'Walk' animation found. Using first available animation for 'talking'.");
                     availableAnimations['talking'] = mixer.clipAction(gltf.animations[0]);
                }
                if (!availableAnimations['thinking']) {
                     console.warn("No 'Run' animation found. Using first available animation for 'thinking'.");
                     availableAnimations['thinking'] = mixer.clipAction(gltf.animations[0]);
                }
                if (!availableAnimations['happy']) {
                     console.warn("No 'Jump' animation found. Using 'talking' animation for 'happy'.");
                     availableAnimations['happy'] = availableAnimations['talking'];
                }


                animateAvatar('listening');
                animate();

            }, undefined, function (error) {
                console.error('An error occurred during GLTF loading:', error);
                document.getElementById('hologram-container').innerHTML = '<p style="color:red; text-align:center;">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØµØ¯ÙŠÙ‚. ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.</p>';
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta); 

            if (avatar) {
                 avatar.rotation.y += (targetRotationY - avatar.rotation.y) * TRACKING_SPEED; 
            }

            renderer.render(scene, camera);
        }
        
        function animateAvatar(state) {
            if (!mixer || !availableAnimations[state]) return;
            
            const newAction = availableAnimations[state];

            if (!newAction || newAction.enabled === false) {
                 console.warn(`Animation clip for state '${state}' is not valid or not enabled.`);
                 return;
            }

            if (currentAction === availableAnimations['happy'] && newAction !== availableAnimations['happy']) {
                 if (currentAction.isRunning()) return; 
            }

            if (currentAction !== newAction) {
                if (currentAction) {
                    currentAction.fadeOut(0.5); 
                }
                newAction.reset().fadeIn(0.5).play(); 
                currentAction = newAction;
            }
        }

        // =======================================================
        // 3. Ù…Ù†Ø·Ù‚ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙˆØ§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø¨ØµØ±ÙŠ (Face Mesh)
        // =======================================================

        async function loadAiModels() {
            document.getElementById('status-message').textContent = 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø¨ØµØ±ÙŠ...';
            
            try {
                faceMeshModel = await faceLandmarksDetection.load(
                    faceLandmarksDetection.SupportedPackages.faceLandmarksDetection,
                    { maxFaces: 1 }
                );
                console.log("Face Mesh loaded successfully.");
                document.getElementById('status-message').textContent = 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø¨ØµØ±ÙŠ.';
                startCameraStream();
            } catch (err) {
                console.error("Failed to load FaceMesh:", err);
                document.getElementById('status-message').textContent = 'âš ï¸ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø¨ØµØ±ÙŠ.';
            }
        }
        
        function startCameraStream() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: "user", 
                        width: { ideal: 640 }, 
                        height: { ideal: 480 }
                    }, 
                    audio: false 
                }) 
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.onloadeddata = () => {
                            poseCanvas.width = videoElement.videoWidth;
                            poseCanvas.height = videoElement.videoHeight;
                            visionLoop();
                        };
                    })
                    .catch(err => {
                        console.error("Failed to access Camera:", err);
                        document.getElementById('status-message').textContent = 'âš ï¸ ÙØ´Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§. Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„Ø¨ØµØ±ÙŠ Ù…Ø¹Ø·Ù„.';
                    });
            }
        }

        async function visionLoop() {
            if (videoElement.readyState < 2 || !faceMeshModel) {
                requestAnimationFrame(visionLoop);
                return;
            }

            try {
                const predictions = await faceMeshModel.estimateFaces({
                    input: videoElement,
                    flipHorizontal: false
                });
                
                if (predictions.length > 0) {
                     const keypoints = predictions[0].scaledMesh;
                     
                     const nose = keypoints[4]; 
                     if (nose) {
                        const videoCenterX = videoElement.videoWidth / 2;
                        const normalizedX = (nose[0] - videoCenterX) / videoCenterX;
                        targetRotationY = normalizedX * (Math.PI / 4); 
                     }
                     
                     const smile = detectSmile(keypoints);
                     if (smile) {
                         animateAvatar('happy'); 
                         document.getElementById('status-message').textContent = 'Ø£Ø±Ù‰ Ø§Ø¨ØªØ³Ø§Ù…ØªÙƒ! ğŸ˜Š';
                     } else {
                         // Ø¥Ø°Ø§ ØªÙˆÙ‚ÙØª Ø§Ù„Ø§Ø¨ØªØ³Ø§Ù…Ø©ØŒ Ù†Ø¹ÙˆØ¯ Ø¥Ù„Ù‰ Ø­Ø±ÙƒØ© Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ (Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±ÙˆØ¨ÙˆØª ÙŠØªØ­Ø¯Ø«)
                         if (currentAction !== availableAnimations['talking'] && currentAction !== availableAnimations['thinking']) {
                             animateAvatar('listening');
                         }
                     }
                } else {
                     // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù ÙˆØ¬Ù‡ØŒ Ù†Ø¹ÙˆØ¯ Ø¥Ù„Ù‰ Ø­Ø±ÙƒØ© Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹
                     if (currentAction !== availableAnimations['talking'] && currentAction !== availableAnimations['thinking']) {
                        animateAvatar('listening');
                    }
                }
            } catch (err) {
                console.error("Error during face estimation:", err);
            }
            
            requestAnimationFrame(visionLoop);
        }
        
        function detectSmile(keypoints) {
            const leftCorner = keypoints[61]; 
            const rightCorner = keypoints[291]; 
            const upperLip = keypoints[13]; 
            const lowerLip = keypoints[14]; 

            if (!leftCorner || !rightCorner || !upperLip || !lowerLip) return false;

            const mouthWidth = Math.abs(leftCorner[0] - rightCorner[0]);
            const mouthHeight = Math.abs(upperLip[1] - lowerLip[1]);
            
            if (mouthHeight < 5) return false; 
            
            const smileRatio = mouthWidth / mouthHeight;

            if (smileRatio > 4.0) { 
                return true;
            }
            return false;
        }


        // =======================================================
        // 4. Ù…Ù†Ø·Ù‚ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ØµÙˆØªÙŠ (STT Ùˆ TTS)
        // =======================================================
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.error("Speech Recognition API is not supported in this browser.");
            document.getElementById('mic-btn').disabled = true;
        }
        
        const recognition = new SpeechRecognition();
        recognition.lang = 'ar-SA';
        recognition.interimResults = false;
        
        const micBtn = document.getElementById('mic-btn');
        const statusMsg = document.getElementById('status-message');
        
        micBtn.addEventListener('click', () => {
            if (micBtn.classList.contains('listening')) {
                recognition.stop();
            } else {
                try {
                    recognition.start();
                } catch(e) {
                    console.error("Recognition start error:", e);
                    statusMsg.textContent = 'Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø§ÙŠÙƒØ±ÙˆÙÙˆÙ†.';
                }
            }
        });
        
        recognition.onstart = () => {
            micBtn.classList.add('listening');
            micBtn.textContent = '...';
            statusMsg.textContent = 'Ø§Ø³ØªÙ…Ø¹ Ø§Ù„Ø¢Ù†...';
            animateAvatar('listening'); 
        };
        
        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            document.getElementById('response-display').innerHTML += `<p><strong>Ø£Ù†Øª:</strong> ${transcript}</p>`;
            sendQueryToAI(transcript); 
        };
        
        recognition.onerror = (event) => {
            statusMsg.textContent = 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø§ÙŠÙƒØ±ÙˆÙÙˆÙ†: ' + event.error;
        };
        
        recognition.onend = () => {
            micBtn.classList.remove('listening');
            micBtn.textContent = 'ğŸ™ï¸';
            statusMsg.textContent = '';
        };

        function readTextAloud(text, callback) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                
                const voices = window.speechSynthesis.getVoices();
                let selectedVoice = voices.find(v => v.lang === 'ar-SA'); 

                const genderVoices = voices.filter(v => v.lang === 'ar-SA');
                if (selectedGender === 'male' && genderVoices.length > 0) {
                    selectedVoice = genderVoices.find(v => v.name.includes('Male') || v.name.includes('male')) || genderVoices[0];
                } else if (selectedGender === 'female' && genderVoices.length > 0) {
                    selectedVoice = genderVoices.find(v => v.name.includes('Female') || v.name.includes('female')) || genderVoices[0];
                }
                
                utterance.voice = selectedVoice;
                utterance.lang = 'ar-SA'; 
                
                utterance.onstart = () => {
                    animateAvatar('talking'); 
                };
                
                utterance.onend = () => {
                    animateAvatar('listening'); 
                    if (callback) callback();
                };

                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙƒÙ„Ø§Ù….');
                if (callback) callback();
            }
        }
        
        window.speechSynthesis.onvoiceschanged = () => {
             console.log("Voices loaded.");
        };


        // =======================================================
        // 5. Ù…Ù†Ø·Ù‚ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø´Ø®ØµÙŠØ© ÙˆØ§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Gemini
        // =======================================================
        
        function selectFriend(gender) {
            selectedGender = gender;
            currentSystemPrompt = (gender === 'male') ? PROMPTS.male : PROMPTS.female;
            
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('main-app').style.display = 'block';
            
            initThreeJS();
            loadAiModels(); 
        }

        async function sendQueryToAI(question) {
            if (!question.trim()) return;

            const display = document.getElementById('response-display');
            
            display.innerHTML += `<p><i>${selectedGender === 'male' ? 'Ø¢Ø¯Ù…' : 'Ø³Ø§Ø±Ø©'} ÙŠÙÙƒØ±...</i></p>`;
            statusMsg.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙÙƒÙŠØ±...';
            animateAvatar('thinking'); 

            try {
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: question }] }],
                        systemInstruction: {
                            parts: [{ text: currentSystemPrompt }]
                        },
                    }),
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}. Check API Key.`);
                }

                const result = await response.json();
                
                const candidate = result.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const aiResponseText = candidate.content.parts[0].text;
                    
                    display.innerHTML += `<p><strong>${selectedGender === 'male' ? 'Ø¢Ø¯Ù…' : 'Ø³Ø§Ø±Ø©'}:</strong> ${aiResponseText}</p>`;
                    readTextAloud(aiResponseText); 
                    statusMsg.textContent = 'Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ­Ø¯Ø«.';

                } else {
                     throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø¯ ØµØ§Ù„Ø­.');
                }
                
            } catch (error) {
                display.innerHTML += `<p><strong>Ø­Ø¯Ø« Ø®Ø·Ø£:</strong> ${error.message}.</p>`;
                statusMsg.textContent = 'ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„.';
                animateAvatar('listening');
            } 
        }
    </script>
</body>
</html>


